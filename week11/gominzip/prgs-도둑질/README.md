# 🔎 문제이름

prgs 도둑질

## 💡 아이디어

- 인접한 두 집을 털면 경보가 울림.
- 경보가 울리지 않도록 최대한 집털기.
- DP 카테고리를 봐버림
- 1, 2, 3, 4, 5의 집이 있을때

  - x집을 털면, x+1의 집은 못턴다.
  - 즉 이전 행동이 영향을 줌.
  - n번째 집을 털때/털지 않을때 가능한 최대 비용 구하기?

- (1:2, 2:5, 3:1 )이 있을때

  - i번째 집을 털었을때: dp[i][0] = dp[i-1][1] + money[i]
  - i번째 집을 털지 않았을때: dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1]);
  - 마지막 집을 털었을때: dp[i][0] = dp[i-1][1] + money[i]

- 첫번째 집을 털었을때
- [[2, 2], [5, 2], [5, 5]]
- 첫번째 집을 털지 않았을때
- [[0,0], [5, 0], [5, 5]]

dp를 2개 둬야할듯?

- dp를 두개 넣고 풀었지만 조금 고려가 부족했음
- 일차원 배열로도 점화식 설정이 가능하다.
- 예를들어, 4개의 집이있고 첫번째 집을 털었을때, 마지막집은 불가능 하므로 [1,2,3]만 체크
- 반대로 첫번째 집을 털지 않았을 때 [2,3,4]만 가능
- 현재 집을 털었을때 가능한 가장 큰 값은 = max(전집의 최대값, 전전집의 최대값 + 현재 값)
- 편한 계산을 위해 앞에 0을 추가하기
  - [0,1,2,3] / [0,2,3,4]

# ✔ 문제풀이

- 1번집을 터는/안터는 경우로 dp 배열을 분리하고 점화식에 따라 계산 진행

## 🤕 어려웠던 점

- 처음 고안한 2차원 배열 방식에서 조금 더 점화식을 잘 떠올리면 1차원으로도 충분히 해결이 가능하다는 걸 알게되었다.. DP는 규칙을 찾고 점화식을 세우는게 80%인거 같다
