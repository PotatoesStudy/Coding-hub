# 🔎 앱

https://www.acmicpc.net/problem/7579

## 💡 아이디어

- 냅색 알고리즘을 활용한다.

## ✔ 문제풀이

### 냅색 자체를 어려워하므로 이 부분은 자세히 적어두기

1. dp를 만들기 위해서 바이트와 비용 배열 맨앞에 0을 넣는다.
2. dp를 초기화한다. -> 행은 바이트 갯수+1, 열은 모든 비용을 더했을 떄의 경우+1로 한다. (0번 인덱스를 활용해야 하기 때문)
3. 1번 행, 0번 열부터 순회하면서 다음과 같은 조건을 확인한다.
   - 행에 있는 byte와 rate를 j열 돌기 전에 변수에 담아둔다.
   - j를 돌때 rate보다 작을 시 dp[i-1][j]를 담는다.
   - byte + dp[i - 1][j - rate], dp[i - 1][j]값을 비교하여 최댓값을 담는다.
4. 조건을 돌면서 dp에 담을 때 dp[i][j]가 필요 M바이트 이상이면 j와 result의 최소를 비교한다.
5. 만약 필요바이트가 0이면 그대로 0을 Print하고 그 이외에는 result를 프린트한다.

## 🤕 어려웠던 점

- 냅색 알고리즘 자체가 어려웠다...
  - 처음에는 이분탐색을 생각했다가 전에꺼를 모두 더하지 않고 중간의 부분만 더하고도 최소가 나오는 경우를 생각하니 답이 없었다.
  - 추후 힌트를 보고 냅색인걸 알았지만 구현을 몰라서 도움을 받았다.
